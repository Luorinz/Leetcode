### medium

Find the **k**th largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.

**Example 1:**

```
Input: [3,2,1,5,6,4] and k = 2
Output: 5
```

**Example 2:**

```
Input: [3,2,3,1,2,4,5,5,6] and k = 4
Output: 4
```

**Note:** 
You may assume k is always valid, 1 ≤ k ≤ array's length.



```python
class Solution_1:
    # built in sort
    # nlogn time
    def findKthLargest(self, nums: 'List[int]', k: 'int') -> 'int':
        nums.sort()
        return nums[-k]
    
class Solution_2:
    # Maxheap
    # n + klogn time, n for sort , logn for pop, k for k items
    # n space
    def findKthLargest(self, nums: 'List[int]', k: 'int') -> 'int':
        nums = [-num for num in nums]
        import heapq
        heapq.heapify(nums)
        res = float('-inf')
        for _ in range(k):
            res = heapq.heappop(nums)
        return -res
    
class Solution_3:
    # Minheap
    # k + nlogk time, k for heapify, logk for push/ pop, n for n nums
    # k space
    def findKthLargest(self, nums: 'List[int]', k: 'int') -> 'int':
        min_heap = [float('-inf')] * k
        import heapq
        heapq.heapify(min_heap)
        for num in nums:
            if num > min_heap[0]:
                heapq.heappushpop(min_heap, num)
        return min_heap[0]
            
class Solution:
    # Minheap
    # k + (n-k)logk time, k for heapify, logk for push/ pop, n-k for nums
    # k space
    def findKthLargest(self, nums: 'List[int]', k: 'int') -> 'int':
        min_heap = nums[:k]
        import heapq
        heapq.heapify(min_heap)
        for i in range(k, len(nums)):
            if nums[i] > min_heap[0]:
                heapq.heappushpop(min_heap, nums[i])
        return min_heap[0]
"""
Max Heap vs. Min Heap
哪个算法更加好？

Max: Time: O(n + klog(n)) | Space: O(n)
Min: Time: O(k) + O((n-k) * logk) | Space: O(K)

如果考虑k无限接近n
Max: O(n + nlog(n)) ~= O(nlogn)
Min: O(n + logk) ~= O(n)

如果考虑k = 0.5n
Max: O(n + nlogn)
Min: O(n + nlogn)

如果考虑n 无限大
Max: O(constant * n) 为什么是constant * n，参考
Min: O(log(k) * n)
"""
```

